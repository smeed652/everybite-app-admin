#!/usr/bin/env node
// updateCoverageMatrix.js – rebuilds docs/storybook/coverage_matrix.md from source
// Tags components as Custom, shadcn, Headless-UI, or Radix based on simple heuristics.
/* eslint-disable no-console */
const { readFileSync, writeFileSync, readdirSync, statSync } = require('fs');
const { join, extname } = require('path');

const projectRoot = join(__dirname, '..');
const srcDir = join(projectRoot, 'src');
const coverageDoc = join(projectRoot, 'docs', 'storybook', 'coverage_matrix.md');

function* walk(dir) {
  for (const entry of readdirSync(dir)) {
    const p = join(dir, entry);
    const s = statSync(p);
    if (s.isDirectory()) yield* walk(p);
    else if (s.isFile() && extname(p) === '.tsx' && !p.endsWith('.stories.tsx') && !p.endsWith('.test.tsx')) {
      yield p;
    }
  }
}

function tag(file) {
  const content = readFileSync(file, 'utf8');
  if (/from\s+'@radix-ui\//.test(content) || /from\s+"@radix-ui\//.test(content)) return 'Radix';
  if (/from\s+'@headlessui\/react'/.test(content) || /from\s+"@headlessui\/react"/.test(content)) return 'Headless UI';
  if (/\/ui\//.test(file.replace(/\\/g, '/'))) return 'shadcn';
  return 'Custom';
}

function componentName(file) {
  const match = /([A-Z][A-Za-z0-9_-]*)\.tsx$/.exec(file);
  return match ? match[1] : file;
}

const sets = { shadcn: [], Radix: [], 'Headless UI': [], Custom: [] };
for (const file of walk(srcDir)) {
  const name = componentName(file);
  const category = tag(file);
  sets[category].push({ name, file: file.replace(projectRoot + '/', '') });
}

for (const key of Object.keys(sets)) {
  sets[key].sort((a, b) => a.name.localeCompare(b.name));
}

function getStoryPath(file) {
  return file.replace(/\.tsx$/, '.stories.tsx');
}

function hasStory(file) {
  const storyPath = getStoryPath(file);
  try {
    return statSync(join(projectRoot, storyPath)).isFile();
  } catch {
    return false;
  }
}

function extractVariants(file) {
  const storyPath = getStoryPath(file);
  try {
    const raw = readFileSync(join(projectRoot, storyPath), 'utf8');
    const matches = [...raw.matchAll(/export const (\w+)/g)].map((m) => m[1]).filter((name) => name.toLowerCase() !== 'meta');
    // Remove duplicates and ignore Default (assumed)
    const uniq = Array.from(new Set(matches.filter((n) => n.toLowerCase() !== 'default')));
    return uniq.sort((a, b) => a.localeCompare(b));
  } catch {
    return [];
  }
}


function section(title, arr) {
  const lines = [`#### ${title}`, '', '| Component | Variants / States | Story | a11y | Tests | Visual |', '|-----------|------------------|-------|------|-------|--------|'];
  for (const { name, file } of arr) {
    const story = hasStory(file) ? '✅' : '❌';
    lines.push(`| ${name} | ${extractVariants(file).join(', ')} | ${story} |  |  |  |`);
  }
  lines.push('');
  return lines.join('\n');
}

const md = [
  '# Storybook Coverage Matrix (Auto-generated)',
  '',
  'This file is generated by `scripts/updateCoverageMatrix.js`. Do not edit manually.',
  '',
  '_Default (✅) story is assumed for each component unless noted._',
  '',
  section('shadcn', sets.shadcn),
  section('Radix primitives', sets.Radix),
  section('Headless UI components', sets['Headless UI']),
  section('Custom components', sets.Custom),
  'Legend: ✅ = completed, ❌ = missing.' ,
  '',
].join('\n');

writeFileSync(coverageDoc, md);
console.log(`Updated ${coverageDoc}`);
